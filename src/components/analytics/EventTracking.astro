---
// This component adds event tracking to important user interactions
// It doesn't render any visible content, but adds event listeners to track user behavior
---

<script>
  // Define the events we want to track
  const trackableEvents = [
    // Calculator usage
    { selector: '.calculator-form', event: 'submit', name: 'calculator_used' },
    { selector: '.calculator-reset', event: 'click', name: 'calculator_reset' },
    
    // Article reading
    { selector: 'article', event: 'scroll', name: 'article_read', threshold: 0.5 },
    
    // Navigation
    { selector: 'nav a', event: 'click', name: 'navigation_click' },
    
    // External links
    { selector: 'a[href^="http"]:not([href*="getlifesorted.com"])', event: 'click', name: 'external_link_click' },
    
    // Downloads
    { selector: 'a[href$=".pdf"], a[href$=".docx"], a[href$=".xlsx"]', event: 'click', name: 'file_download' }
  ];

  // Only track events if consent is given
  function hasAnalyticsConsent() {
    return window.glsConsent?.hasAnalyticsConsent() || false;
  }

  // Track a specific event
  function trackEvent(eventName, props = {}) {
    if (hasAnalyticsConsent() && window.plausible) {
      window.plausible(eventName, { props });
    }
  }

  // Set up scroll tracking for articles
  function setupScrollTracking() {
    const articles = document.querySelectorAll('article');
    
    if (articles.length === 0) return;
    
    let hasTrackedArticleRead = false;
    
    // Use Intersection Observer to detect when article is 50% visible
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && entry.intersectionRatio >= 0.5 && !hasTrackedArticleRead) {
          const article = entry.target;
          const articleTitle = article.querySelector('h1')?.textContent || 'Unknown Article';
          const articlePath = window.location.pathname;
          
          trackEvent('article_read', { 
            title: articleTitle,
            path: articlePath
          });
          
          hasTrackedArticleRead = true;
          observer.disconnect(); // Stop observing once tracked
        }
      });
    }, {
      threshold: 0.5 // Track when 50% of article is visible
    });
    
    articles.forEach(article => observer.observe(article));
  }

  // Set up click tracking
  function setupClickTracking() {
    trackableEvents.forEach(trackableEvent => {
      if (trackableEvent.event !== 'scroll') { // Handle scroll events separately
        const elements = document.querySelectorAll(trackableEvent.selector);
        
        elements.forEach(element => {
          element.addEventListener(trackableEvent.event, (e) => {
            if (!hasAnalyticsConsent()) return;
            
            // Get additional properties based on element type
            const props = {};
            
            if (element.tagName === 'A') {
              props.url = element.href;
              props.text = element.textContent || 'Unknown';
            } else if (trackableEvent.name === 'calculator_used') {
              // For calculator submissions, capture calculator type
              const calculatorType = element.closest('[data-calculator-type]')?.dataset.calculatorType || 'Unknown';
              props.calculator_type = calculatorType;
            }
            
            trackEvent(trackableEvent.name, props);
          });
        });
      }
    });
  }

  // Initialize tracking
  function initializeTracking() {
    if (hasAnalyticsConsent()) {
      setupScrollTracking();
      setupClickTracking();
    }
  }

  // Set up tracking when the page loads
  window.addEventListener('load', initializeTracking);
  
  // Re-initialize tracking when consent is updated
  window.addEventListener('consentUpdated', (event) => {
    const { analytics } = (event as CustomEvent).detail;
    
    if (analytics) {
      initializeTracking();
    }
  });
</script>